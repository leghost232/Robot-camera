import cv2
import numpy as np

def adjust_brightness_contrast(frame, alpha=1.3, beta=30):
    """
    Adjust brightness and contrast of the frame for better shape visibility.
    alpha: Contrast control (1.0-3.0)
    beta: Brightness control (0-100)
    """
    return cv2.convertScaleAbs(frame, alpha=alpha, beta=beta)

def detect_shapes(frame):
    # Convert the frame to grayscale
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Adjust brightness and contrast for better visibility
    gray = adjust_brightness_contrast(gray, alpha=1.5, beta=30)

    # Apply GaussianBlur to reduce noise and improve edge detection
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)

    # Perform edge detection using Canny
    edges = cv2.Canny(blurred, 50, 150)

    # Find contours from the edges
    contours, hierarchy = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Create a copy of the frame to draw the contours
    result_frame = frame.copy()

    # Loop through each contour
    for contour in contours:
        # Ignore small contours that are less likely to be relevant shapes (noise filtering)
        if cv2.contourArea(contour) < 300:  # Increase this value for larger shapes
            continue

        # Approximate the contour to reduce the number of vertices and smooth out the shape
        epsilon = 0.04 * cv2.arcLength(contour, True)
        approx = cv2.approxPolyDP(contour, epsilon, True)
        
        # Get the number of vertices in the approximated polygon
        num_vertices = len(approx)

        # Classify the shape based on the number of vertices
        if num_vertices == 3:
            shape = "Triangle"
        elif num_vertices == 4:
            # Check if the quadrilateral is a square or rectangle
            x, y, w, h = cv2.boundingRect(approx)
            aspect_ratio = float(w) / h
            if 0.95 < aspect_ratio < 1.05:
                shape = "Square"
            else:
                shape = "Rectangle"
        elif num_vertices == 5:
            shape = "Pentagon"
        elif num_vertices == 6:
            shape = "Hexagon"
        else:
            shape = "Circle"

        # Draw the contour and put the shape name on the frame
        cv2.drawContours(result_frame, [approx], -1, (0, 255, 0), 2)
        
        # Get the center of the contour to place the shape name
        M = cv2.moments(contour)
        if M["m00"] != 0:
            cX = int(M["m10"] / M["m00"])
            cY = int(M["m01"] / M["m00"])
        else:
            cX, cY = 0, 0

        # Add the shape name at the center of the detected shape
        cv2.putText(result_frame, shape, (cX - 50, cY), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)

    # Use Hough Circle Transform to detect circles (if any)
    circles = cv2.HoughCircles(
        gray,
        cv2.HOUGH_GRADIENT, dp=1.2, minDist=40, param1=100, param2=30, minRadius=20, maxRadius=60
    )

    # If we find circles, draw them
    if circles is not None:
        circles = np.round(circles[0, :]).astype("int")
        for (x, y, r) in circles:
            cv2.circle(result_frame, (x, y), r, (0, 0, 255), 4)
            cv2.putText(result_frame, "Circle", (x - 40, y - r - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)

    return result_frame

def main():
    # Initialize the camera (0 is typically the default camera)
    cap = cv2.VideoCapture(0)

    if not cap.isOpened():
        print("Error: Could not open video stream.")
        return

    # Loop to capture frames from the camera
    while True:
        # Capture frame-by-frame
        ret, frame = cap.read()

        if not ret:
            print("Failed to grab frame")
            break

        # Detect shapes in the captured frame
        result_frame = detect_shapes(frame)

        # Display the result
        cv2.imshow("Detected Shapes", result_frame)

        # Break the loop when the user presses 'q'
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Release the camera and close all windows
    cap.release()
    cv2.destroyAllWindows()

# Run the main function
if __name__ == "__main__":
    main()
